# -*- coding: utf-8 -*-
"""
Created on Sat Oct 25 14:28:27 2025

@author: user
"""

"""
Circuit Routing Visualization Tool
Visualize the actual PCB routing generated by the trained agent
"""

import torch
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
from matplotlib.collections import LineCollection
import matplotlib.animation as animation
from PIL import Image
import os
import sys

sys.path.append('.')
from envs.circuit_routing import CircuitRoutingEnv


def visualize_single_layer(env, layer_idx, ax, title=None):
    """Visualize a single PCB layer"""
    grid = env.routing_grid[:, :, layer_idx]
    
    # Color map for different elements
    cmap = plt.cm.colors.ListedColormap(['white', 'lightgreen', 'blue', 'red'])
    bounds = [0, 0.25, 0.6, 0.9, 1.0]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)
    
    im = ax.imshow(grid.T, cmap=cmap, norm=norm, origin='lower', interpolation='nearest')
    
    # Mark component positions
    for comp_pos in env.component_positions:
        x, y = int(comp_pos[0]), int(comp_pos[1])
        circle = Circle((x, y), radius=2, color='darkblue', alpha=0.7, zorder=5)
        ax.add_patch(circle)
    
    # Mark pins on this layer
    pins_on_layer = [p for p in env.pins if p.layer == layer_idx]
    for pin in pins_on_layer:
        ax.plot(pin.x, pin.y, 'r*', markersize=8, zorder=10)
    
    # Mark vias
    vias_on_layer = [v for v in env.vias if v.from_layer <= layer_idx <= v.to_layer]
    for via in vias_on_layer:
        circle = Circle((via.x, via.y), radius=1, color='yellow', 
                       edgecolor='black', linewidth=1, zorder=8)
        ax.add_patch(circle)
    
    ax.set_xlim(-0.5, env.grid_size[0] - 0.5)
    ax.set_ylim(-0.5, env.grid_size[1] - 0.5)
    ax.set_aspect('equal')
    
    if title:
        ax.set_title(title, fontsize=12, fontweight='bold')
    else:
        ax.set_title(f'Layer {layer_idx + 1}', fontsize=12, fontweight='bold')
    
    ax.grid(True, alpha=0.3)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    
    return im


def visualize_all_layers(env, save_path=None):
    """Visualize all PCB layers"""
    num_layers = env.num_layers
    cols = min(4, num_layers)
    rows = (num_layers + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 5*rows))
    fig.suptitle('Multi-layer PCB Routing Result', fontsize=16, fontweight='bold')
    
    if num_layers == 1:
        axes = [axes]
    else:
        axes = axes.flatten() if num_layers > cols else axes
    
    for layer_idx in range(num_layers):
        ax = axes[layer_idx] if isinstance(axes, (list, np.ndarray)) else axes
        visualize_single_layer(env, layer_idx, ax, f'Layer {layer_idx + 1}')
    
    # Hide extra subplots
    if isinstance(axes, (list, np.ndarray)):
        for idx in range(num_layers, len(axes)):
            axes[idx].axis('off')
    
    # Add legend
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='white', edgecolor='black', label='Empty'),
        Patch(facecolor='lightgreen', edgecolor='black', label='Trace (0.5)'),
        Patch(facecolor='blue', edgecolor='black', label='Via (0.8)'),
        Patch(facecolor='red', edgecolor='black', label='Pin (1.0)'),
        Circle((0, 0), radius=0.1, color='darkblue', label='Component'),
        Circle((0, 0), radius=0.1, color='yellow', edgecolor='black', label='Via')
    ]
    fig.legend(handles=legend_elements, loc='lower center', ncol=6, 
               bbox_to_anchor=(0.5, -0.02), fontsize=10)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"ðŸ’¾ Saved to: {save_path}")
    
    plt.show()


def visualize_3d_routing(env, save_path=None):
    """3D visualization of multi-layer routing"""
    from mpl_toolkits.mplot3d import Axes3D
    
    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')
    
    # Color for each layer
    layer_colors = ['red', 'green', 'blue', 'yellow', 'magenta', 'cyan', 'orange', 'purple']
    
    # Plot traces on each layer
    for layer_idx in range(env.num_layers):
        grid = env.routing_grid[:, :, layer_idx]
        z = layer_idx
        
        # Find trace positions
        trace_positions = np.where(grid == 0.5)
        if len(trace_positions[0]) > 0:
            ax.scatter(trace_positions[0], trace_positions[1], 
                      [z] * len(trace_positions[0]),
                      c=layer_colors[layer_idx % len(layer_colors)],
                      marker='s', s=20, alpha=0.6,
                      label=f'Layer {layer_idx + 1} Traces')
        
        # Pin positions
        pin_positions = np.where(grid == 1.0)
        if len(pin_positions[0]) > 0:
            ax.scatter(pin_positions[0], pin_positions[1],
                      [z] * len(pin_positions[0]),
                      c='red', marker='*', s=100, edgecolors='black',
                      linewidths=1, alpha=0.9)
    
    # Plot vias (connecting layers)
    for via in env.vias:
        z_coords = list(range(via.from_layer, via.to_layer + 1))
        x_coords = [via.x] * len(z_coords)
        y_coords = [via.y] * len(z_coords)
        ax.plot(x_coords, y_coords, z_coords, 'ko-', linewidth=3, 
                markersize=6, alpha=0.8)
    
    # Plot components
    for comp_pos in env.component_positions:
        x, y = comp_pos[0], comp_pos[1]
        # Draw vertical line through all layers
        ax.plot([x, x], [y, y], [0, env.num_layers - 1],
               'b-', linewidth=4, alpha=0.5)
    
    ax.set_xlabel('X', fontsize=12)
    ax.set_ylabel('Y', fontsize=12)
    ax.set_zlabel('Layer', fontsize=12)
    ax.set_title('3D Multi-layer PCB Routing', fontsize=14, fontweight='bold')
    
    ax.set_xlim(0, env.grid_size[0])
    ax.set_ylim(0, env.grid_size[1])
    ax.set_zlim(0, env.num_layers - 1)
    
    # Set layer ticks
    ax.set_zticks(range(env.num_layers))
    ax.set_zticklabels([f'L{i+1}' for i in range(env.num_layers)])
    
    ax.legend(loc='upper right', fontsize=9)
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"ðŸ’¾ 3D view saved to: {save_path}")
    
    plt.show()


def visualize_routing_process(agent, env, save_dir='./routing_visualizations'):
    """Visualize step-by-step routing process"""
    os.makedirs(save_dir, exist_ok=True)
    
    obs = env.reset()
    done = False
    step = 0
    
    # Store frames
    frames = []
    metrics_history = {
        'wire_length': [],
        'si_pi_performance': [],
        'drc_violations': [],
        'unrouted_nets': []
    }
    
    print(f"\nðŸŽ¬ Generating routing process visualization...")
    
    while not done and step < env.max_iterations:
        # Select action
        action, _, _ = agent.select_action(obs, deterministic=True)
        
        # Step
        obs, reward, done, info = env.step(action)
        
        # Record metrics
        metrics_history['wire_length'].append(env.wire_length)
        metrics_history['si_pi_performance'].append(env.si_pi_performance)
        metrics_history['drc_violations'].append(sum(env.drc_violations.values()))
        metrics_history['unrouted_nets'].append(env.unrouted_nets)
        
        # Save frame every N steps
        if step % 5 == 0 or done:
            fig, axes = plt.subplots(1, 2, figsize=(14, 6))
            
            # Left: routing visualization
            # Show composite of all layers
            composite = np.max(env.routing_grid, axis=2)
            im = axes[0].imshow(composite.T, cmap='viridis', origin='lower', 
                               interpolation='nearest')
            
            # Mark components
            for comp_pos in env.component_positions:
                x, y = int(comp_pos[0]), int(comp_pos[1])
                circle = Circle((x, y), radius=2, color='red', alpha=0.7)
                axes[0].add_patch(circle)
            
            axes[0].set_title(f'Step {step}: Routing Progress', fontsize=12, fontweight='bold')
            axes[0].set_xlabel('X')
            axes[0].set_ylabel('Y')
            axes[0].grid(True, alpha=0.3)
            plt.colorbar(im, ax=axes[0], label='Grid Value')
            
            # Right: metrics
            axes[1].clear()
            x_steps = range(len(metrics_history['wire_length']))
            
            ax1 = axes[1]
            color = 'tab:blue'
            ax1.set_xlabel('Step')
            ax1.set_ylabel('Wire Length', color=color)
            ax1.plot(x_steps, metrics_history['wire_length'], color=color, linewidth=2)
            ax1.tick_params(axis='y', labelcolor=color)
            ax1.axhline(env.wire_length_threshold, color=color, linestyle='--', alpha=0.5)
            
            ax2 = ax1.twinx()
            color = 'tab:orange'
            ax2.set_ylabel('SI/PI Performance', color=color)
            ax2.plot(x_steps, metrics_history['si_pi_performance'], color=color, linewidth=2)
            ax2.tick_params(axis='y', labelcolor=color)
            ax2.axhline(env.si_pi_threshold, color=color, linestyle='--', alpha=0.5)
            
            axes[1].set_title('Performance Metrics', fontsize=12, fontweight='bold')
            
            fig.tight_layout()
            
            # Save frame
            frame_path = os.path.join(save_dir, f'frame_{step:04d}.png')
            plt.savefig(frame_path, dpi=150, bbox_inches='tight')
            frames.append(frame_path)
            plt.close(fig)
        
        step += 1
    
    print(f"âœ… Generated {len(frames)} frames")
    
    # Create final summary plot
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    fig.suptitle('Routing Process Summary', fontsize=16, fontweight='bold')
    
    # Wire Length
    axes[0, 0].plot(metrics_history['wire_length'], linewidth=2)
    axes[0, 0].axhline(env.wire_length_threshold, color='r', linestyle='--', 
                       label='Threshold', linewidth=2)
    axes[0, 0].set_xlabel('Step')
    axes[0, 0].set_ylabel('Wire Length')
    axes[0, 0].set_title('Wire Length Over Time')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # SI/PI Performance
    axes[0, 1].plot(metrics_history['si_pi_performance'], linewidth=2, color='orange')
    axes[0, 1].axhline(env.si_pi_threshold, color='r', linestyle='--', 
                       label='Threshold', linewidth=2)
    axes[0, 1].set_xlabel('Step')
    axes[0, 1].set_ylabel('SI/PI Performance')
    axes[0, 1].set_title('SI/PI Performance Over Time')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)
    
    # DRC Violations
    axes[1, 0].plot(metrics_history['drc_violations'], linewidth=2, color='red')
    axes[1, 0].fill_between(range(len(metrics_history['drc_violations'])),
                            metrics_history['drc_violations'], alpha=0.3, color='red')
    axes[1, 0].set_xlabel('Step')
    axes[1, 0].set_ylabel('DRC Violations')
    axes[1, 0].set_title('DRC Violations Over Time')
    axes[1, 0].grid(True, alpha=0.3)
    
    # Unrouted Nets
    axes[1, 1].plot(metrics_history['unrouted_nets'], linewidth=2, color='purple')
    axes[1, 1].fill_between(range(len(metrics_history['unrouted_nets'])),
                            metrics_history['unrouted_nets'], alpha=0.3, color='purple')
    axes[1, 1].set_xlabel('Step')
    axes[1, 1].set_ylabel('Unrouted Nets')
    axes[1, 1].set_title('Unrouted Nets Over Time')
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    summary_path = os.path.join(save_dir, 'routing_summary.png')
    plt.savefig(summary_path, dpi=300, bbox_inches='tight')
    print(f"ðŸ’¾ Summary saved to: {summary_path}")
    plt.show()
    
    return frames


def show_detailed_statistics(env):
    """Show detailed routing statistics"""
    print("\n" + "="*70)
    print("ðŸ“Š DETAILED ROUTING STATISTICS")
    print("="*70)
    
    print(f"\nðŸ”§ Circuit Configuration:")
    print(f"  Grid Size:         {env.grid_size[0]} Ã— {env.grid_size[1]}")
    print(f"  Number of Layers:  {env.num_layers}")
    print(f"  Components:        {env.num_components}")
    print(f"  Total Pins:        {len(env.pins)}")
    print(f"  Total Nets:        {len(env.nets)}")
    
    print(f"\nðŸ“ Routing Metrics:")
    print(f"  Wire Length:       {env.wire_length:.2f} / {env.wire_length_threshold:.2f}")
    print(f"  SI/PI Performance: {env.si_pi_performance:.3f} / {env.si_pi_threshold:.3f}")
    print(f"  Total Vias:        {env.total_vias}")
    print(f"  Unrouted Nets:     {env.unrouted_nets}")
    
    print(f"\nâš ï¸  DRC Violations:")
    for violation_type, count in env.drc_violations.items():
        status = "âœ…" if count == 0 else "âŒ"
        print(f"  {status} {violation_type:20s}: {count}")
    
    total_violations = sum(env.drc_violations.values())
    print(f"  {'â”€'*40}")
    print(f"  {'Total Violations:':22s} {total_violations}")
    
    print(f"\nðŸ“ Pin Distribution by Layer:")
    for layer in range(env.num_layers):
        pins_on_layer = [p for p in env.pins if p.layer == layer]
        print(f"  Layer {layer + 1}: {len(pins_on_layer):3d} pins")
    
    print(f"\nâœ… Success Criteria:")
    drc_pass = "âœ… PASS" if env._check_design_rules() else "âŒ FAIL"
    perf_pass = "âœ… PASS" if env._check_performance_threshold() else "âŒ FAIL"
    overall = "âœ… SUCCESS" if (env._check_design_rules() and env._check_performance_threshold()) else "âŒ FAILED"
    
    print(f"  DRC Rules:         {drc_pass}")
    print(f"  Performance:       {perf_pass}")
    print(f"  Overall:           {overall}")
    
    print("="*70 + "\n")


def main():
    import argparse
    from ppo_train_circuit import PPOAgent
    
    parser = argparse.ArgumentParser(description='Visualize Circuit Routing')
    parser.add_argument('--model_path', type=str,
                        default='./ppo_circuit_routing/ppo_circuit_final.pt',
                        help='Path to trained model')
    parser.add_argument('--task', type=str, default='circuit_routing_easy',
                        help='Task name')
    parser.add_argument('--mode', type=str, default='all',
                        choices=['layers', '3d', 'process', 'all'],
                        help='Visualization mode')
    parser.add_argument('--save_dir', type=str, default='./circuit_visualizations',
                        help='Directory to save visualizations')
    
    args = parser.parse_args()
    
    os.makedirs(args.save_dir, exist_ok=True)
    
    # Create environment
    env = CircuitRoutingEnv(task=args.task)
    image_shape = env.obs_space['image']['shape']
    vector_dim = env.obs_space['vector']['shape'][0]
    action_dim = env.act_space['action']['discrete']
    
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    
    # Load agent
    agent = PPOAgent(image_shape, vector_dim, action_dim, device=device)
    agent.load(args.model_path)
    
    print(f"\nðŸŽ¨ Visualizing Circuit Routing")
    print(f"   Task: {args.task}")
    print(f"   Mode: {args.mode}")
    
    # Run one episode to completion
    obs = env.reset()
    done = False
    total_reward = 0
    
    print(f"\nðŸƒ Running episode to completion...")
    while not done:
        action, _, _ = agent.select_action(obs, deterministic=True)
        obs, reward, done, _ = env.step(action)
        total_reward += reward
    
    print(f"âœ… Episode completed with reward: {total_reward:.2f}")
    
    # Show statistics
    show_detailed_statistics(env)
    
    # Visualizations
    if args.mode in ['layers', 'all']:
        print("\nðŸ“Š Generating layer-by-layer visualization...")
        visualize_all_layers(env, save_path=os.path.join(args.save_dir, 'all_layers.png'))
    
    if args.mode in ['3d', 'all']:
        print("\nðŸŽ² Generating 3D visualization...")
        visualize_3d_routing(env, save_path=os.path.join(args.save_dir, '3d_routing.png'))
    
    if args.mode == 'process':
        print("\nðŸŽ¬ Generating step-by-step process...")
        visualize_routing_process(agent, env, save_dir=args.save_dir)


if __name__ == '__main__':
    main()